\documentclass[12pt, oneside]{article} 

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage[bulgarian]{babel}
\usepackage{syntax}
\usepackage{amsthm}
\usepackage{qtree}
\usepackage{listings}
\lstset
{ %Formatting for code
    language=csh,
    basicstyle=\footnotesize,
    numbers=left,
    stepnumber=1,
    showstringspaces=false,
    tabsize=1,
    breaklines=true,
    breakatwhitespace=false,
}


\theoremstyle{definition}
\newtheorem{definition}{Дефиниция}[section]
\newtheorem{theorem}{Теорема}[section]
\newtheorem{construction}{Конструкция}[section]
\newtheorem{example}{Пример}[section]
\newtheorem{proposition}{Твърдение}[section]
\newtheorem{corollary}{Следствие}[section]

\counterwithin{figure}{section}

\usepackage{geometry}
\geometry{letterpaper}

% \usepackage[pdf]{graphicx}
% \usepackage{dot2texi}

\usepackage{tikz}
\usetikzlibrary{automata,positioning,snakes,arrows,shapes,decorations.pathreplacing,patterns}
\usepackage{amsmath}
\usepackage[]{algorithm2e}

% \setlength{\parskip}{1em}

\title{Лексически Анализ чрез Бимашини}

\begin{document}

\tableofcontents

\pagebreak
\section{Увод}

Основна задача на лексическият анализатор е да чете символите на входния текст, да ги групира под формата на лексеми (тоукъни) и извежда като изход редица от тези лексеми. Лексемата е структура от данни, която съдържа нейния тип, текст и позиция във входния текст. Тази информация в последствие се подава на парсър, който от своя страна извършва синтактичният анализ на текста.

Лексическите анализатори могат да се използват и за други цели освен идентификация на лексемите, като на пример за премахване на сегменти от текст (като нови редове, интервали и пр.), броене на символи, или думи, както и за проверка за грешки.

Лексемите се дефинират чрез регулярни изрази. Генератор за лексически анализ получава редица от регулярни изрази като вход и въз основа на тях строи лексически анализатор.

В тази работа представяме алгоритъм за конструкция на лексически анализатор по зададено множество от регулярни изрази. Анализаторът извлича лексемите за линейно време спрямо дължината на входния текст, като го сканира едновременно от ляво на дясно и от дясно на ляво използвайки бимашина.

% \pagebreak

\subsection{Мотивация}

Съществуващите генератори на лексически анализатори като Lex, Flex и ANTLR намират широко приложение в индустрията. Те позволяват на потребителя да подаде спецификация на лексемите (лексическа граматика) под формата на регулярни изрази и генерират програма, която извършва токенизацията входен текст спрямо тази спецификация.

Тези инструменти работят на сходен принцип. По регулярните изрази на всяко правило от граматиката, те строят крайни автомати, които в последствие се обединяват (Фигура \ref{fig:FaUnion}). Токенизацията се извършва, като полученият автомат се симулира чрез сканиране на текста от ляво на дясно. 
Ако при прочетен символ, автоматът не може да направи преход към нито едно състояние, то последното посетено финално състояние определя лексемата, която да се изведе, автоматът преминава обратно в началното си състояние и сканирането на входния текст продължава от от символа, който е бил прочетен, когато автоматът се е намирал във въпросното финално състояние. Ако автоматът не може да продължи и междувременно не е посетено финално състояние, то входния текст не е коректен спрямо лексическата граматика.

\begin{figure}[!htb]
	\centering
	\includegraphics[
		height=5cm,
		keepaspectratio,
	  ]{img/fa-union.png}
	\caption{Краен автомат, получен от обединението на автоматите от лексическа граматика с n на брой правила.}
	\label{fig:FaUnion}
\end{figure}

\begin{example}
	Нека разгледаме следната спецификация:
	\begin{figure}[!htb]
		\begin{center}
			\begin{tabular}{ |l|l| } 
			\hline
			Token & Description \\
			\hline
			Id & \verb/[a-zA-Z_][a-zA-Z0-9_]*/ \\
			Number & \verb/[0-9]+(\.[0-9]+)?/ \\
			Boolean & \verb/true|false/ \\
			Operator & \verb/=|==|!=|<|<=|>|>=/ \\
			If & \verb/if/ \\
			Else & \verb/else/ \\
			Return & \verb/return/ \\
			BraceOpen & \verb/{/ \\
			BraceClose & \verb/}/\\
			WS & \verb/[ \t\r\n]+/ \\
			\hline
			\end{tabular}
		\end{center}
		\label{fig:Lexgr1}
		\caption{Лексическа граматика}
	\end{figure}

	\noindent Входният текст \emph{"num\textunderscore1=90.4"}, се разбива на следните лексеми: \\ (\emph{num\textunderscore1}, \textbf{Id}), (\emph{=}, \textbf{Operator}), (\emph{90.4}, \textbf{Number}).

	\noindent Друг пример е думата \emph{"if valid==true return 0"}, за която получаваме: \\ (\emph{if}, \textbf{If}), (\emph{' '}, \textbf{WS}), (\emph{valid}, \textbf{Id}), (\emph{==}, \textbf{Operator}), (\emph{true}, \textbf{Boolean}), (\emph{' '}, \textbf{WS}), \\ (\emph{return}, \textbf{Return}), (\emph{' '}, \textbf{WS}), (\emph{0}, \textbf{Number}).

	Всяко правило се представя чрез краен автомат, като на пример този за "Boolean" е изобразен на Фигура \ref{fig:Fa1}.

	\begin{figure}[!htb]
		\centering
		\includegraphics[
			width=12cm,
			keepaspectratio,
	  	]{img/fa1.png}
		\caption{Краен автомат разпознаващ думите \emph{true} или \emph{false}}
		\label{fig:Fa1}
	\end{figure}

	След като автоматите за всяко правило са построени, следващата стъпка е да се обединят в единствен краен автомат (Фигура \ref{fig:Fa3}), който се симулира по време на сканирането на входния текст.

	\begin{figure}[!htb]
		\centering
		\includegraphics[
			width=16cm,
			height=8cm,
			keepaspectratio,
	  	]{img/fa3.png}
		\caption{Краен автомат, получен от обединението на автоматите от лексическата граматика. За яснота са изобразени само Boolean, Operator и Number.}
		\label{fig:Fa3}
	\end{figure}
	Нека разгледаме входния текст \emph{"1 > 0.99 == true"}. Преди да започнем да го четем, авоматът се намира в началното си състояние 0. Четем \emph{'1'} и преминаваме в състояние 5. Следващият символ е \emph{'>'}, за който няма преход. Намираме се във финално състояние на автомата на лексемата Number, съответно извеждаме (\emph{1}, \textbf{Number}) и се връщаме в началното състояние. Аналогично от 0 имаме преход с \emph{'>'}, който води до състояние 3, което е финално. Няма преход от 3 на \emph{'0'}, съответно извеждаме (\emph{>}, \textbf{Operator}) и се връщаме в 0. Прочитайки \emph{'0'}, автоматът преминава в състояние 5, което е финално, но следващият символ е \emph{'.'}, така че можем да продължим със симулацията като стигаме до състояние 12 и извеждаме (\emph{'0.99'}, \textbf{Number}). Аналогично по пътя 0,3,8 ще изведем (\emph{'=='}, \textbf{Operator}) и в последствие по 0,1,6,10,13 ще изведем (\emph{'true'}, \textbf{Boolean}), като с това сме изчерпали символите в тескта и процедурата приключва.
\end{example}

В определени случаи този подход може да се окаже неефективен. Нека разгледаме следния прост пример.

\begin{figure}[!htb]
	\begin{center}
		\begin{tabular}{ |l|l| } 
		\hline
		Token & Description \\
		\hline
		A & \verb/а/ \\
		B & \verb/a+b/ \\
		\hline
		\end{tabular}
	\end{center}
	\centering
	\begingroup
		\tikzset{every picture/.style={scale=0.75}}%
		\input{img/fa-union2.tex}
	\endgroup
	\label{fig:Lexgr2}
	\caption{Лексическа граматика и построеният по нея краен автомат.}
\end{figure}

\begin{example}
	Граматиката на Фигура \ref{fig:Lexgr2} съдържа две правила. Правило \textbf{A} представлява единствено думата \emph{"a"}. Правило \textbf{B} обхваща думите, съдържащи \emph{'a'} поне веднъж, които завършват с \emph{'b'} като на пример \emph{"ab", "aab", "aaab"} и т.н. Входният текст \emph{"aabaa} се разбива на следните лексеми: (\emph{'aab'}, \textbf{B}), (\emph{'a'}, \textbf{A}), (\emph{'a'}, \textbf{A}).

	Нека разгледаме случая, в който сканираме текста \emph{"aaaaaaaaаа"}, състоящ се от десет еднакви тоукъна - (\emph{'a'}, \textbf{A}). Очевидно, за да изведем \textbf{А} е необходимо да сканираме текста до самия му край, за да се уверим, че не съществува \emph{'b'}. Това се случва за всеки изведен тоукън, което води до неоптимална сложност на процедурата от \( \mathcal{O}(n^2) \).
\end{example}

Лексическият анализ чрез бимашина се справя с този проблем като сканирането на текста се случва едновременно от ляво на дясно и от дясно на ляво, с което се гарантира линейно време на изпълнение. Целта на тази работа е да се представи конструкция на такава бимашина по зададена лексическа граматика и алгоритъм за осъществяване на лексически анализ.

\pagebreak
\section{Основни дефиниции}

\subsection{Крайни автомати}

\begin{definition}
	\emph{Краен автомат} дефинираме като петорка \( \mathcal{A} = \langle \Sigma, Q, I, F, \Delta \rangle \), където

	\begin{itemize}
		\item \( \Sigma \) е \emph{крайна азбука от символи}
		\item \( Q \) е \emph{крайно множество от състояния}
		\item \( I \subseteq Q \) е \emph{множество от начални състояния}
		\item \( F \subseteq Q \) е \emph{множество от финални състояния}
		\item \( \Delta \subseteq Q \times \Sigma \times Q \) е \emph{релация на прехода}
	\end{itemize}
 
	Тройки от вида \( \langle q_1, m, q_2 \rangle \in \Delta \) наричаме \emph{преходи} и казваме, че започва състояние \( q_1 \), има етикет \( m \) и завършва в състояние \( q_2 \). Алтернативно, тези преходи обозначаваме като \( q_1 \to^m q_2 \).
\end{definition}

\begin{definition}  
	Нека \( \mathcal{A} \) е краен автомат. \emph{Разширена релация на прехода} \( \Delta^* \subseteq Q \times \Sigma^* \times Q \) дефинираме индуктивно:

	\begin{itemize}
		\item \( \langle q, \epsilon, q \rangle \in \Delta^* \) за всяко \( q \in Q \)
		\item \( \langle q_1, wa, q_2 \rangle \in \Delta^* \) за всяко \( q_1, q_2, q \in Q \), \( a \in \Sigma, w \in \Sigma^* \), ако \( \langle q_1, w, q \rangle \in \Delta^* \) и \( \langle q, a, q_2 \rangle \in \Delta \)
	\end{itemize}
\end{definition}

\begin{definition} 
	Нека \( \mathcal{A} = \langle \Sigma, Q, I, F, \Delta \rangle \) е краен автомат. \emph{Път} в \( \mathcal{A} \) наричаме крайна редица от преходи с дължина \( k > 0 \) 
	\[ \pi = q_0 \to^{a_1} q_1 \to^{a_2} \ldots \to^{a_k} q_k \] 
	където \( \langle q_{i-1}, a_i, q_i \rangle \in \Delta \) за \( i = 1 \ldots k \). Казваме, че \emph{пътят} започва от състояние \( q_0 \) и завършва в състояние \( q_k \). Елементите \( q_0,q_1, \ldots ,q_k \) наричаме \emph{състояния на пътя}, а думата \( w = a_1 a_2 \ldots a_k \) наричаме \emph{етикет на пътя}. \newline \emph{Успешен път} в автомата е \emph{път}, който започва от начално състояние и завършва във финално състояние.
\end{definition}

\begin{figure}[!htb]
	\centering
	\input{img/nfa.tex}
	\caption{Недетерминиран краен автомат}
	\label{fig:Nfa}
\end{figure}

\begin{example}
	Нека е зададена азбука \( \Sigma = \{ a,b,\epsilon \} \) и автомат \( \mathcal{A} \) над \( \Sigma \) със състояния \( Q = \{ 0, 1, 2 \} \), начални \( I = \{ 0 \} \), финални \( F = \{ 0 \} \) и релация на прехода 
	\[ \Delta = \{ \langle 0, b, 1 \rangle, \langle 0, \epsilon, 2 \rangle, \langle 1, a, 1 \rangle, \langle 1, a, 2 \rangle \, \langle 1, b, 2 \rangle, \langle 2, a, 0 \rangle \} \]
	\( \mathcal{A} \) е изобразен на Фигура \ref{fig:Nfa}. \( 0 \to^{b} 1 \to^{a} 1 \to^{b} 2 \to^{a} 0 \) е успешен път, разпознавайки думата \emph{baba}.
\end{example}

\begin{definition} 
	Нека \( \mathcal{A} \) е краен автомат. Множеството от етикети на всички успещни пътища в \( \mathcal{A} \) наричаме \emph{език на \( \mathcal{A} \)} и обозначаваме като \( L(\mathcal{A}) \). \[ L(\mathcal{A}) = \{ w \in \Sigma^* \mid \exists i \in I, f \in F : \langle i, w, f \rangle \in \Delta^* \} \]
\end{definition}

\begin{definition} 
	Нека \( \mathcal{A}_1 \) и \( \mathcal{A}_2 \) са крайни автомати. Казваме, че \( \mathcal{A}_1 \) е еквивалентен на \( \mathcal{A}_2 \) (\( \mathcal{A}_1 \equiv \mathcal{A}_2 \)), ако езиците им съвпадат (\( L(\mathcal{A}_1) = L(\mathcal{A}_2) \))
\end{definition}

\begin{definition}
	Нека \( \mathcal{A} = \langle \Sigma, Q, I, F, \Delta \rangle \) е краен автомат. Автоматът \(\mathcal{A'} = \langle Q, F, I, \Delta' \), където \( \Delta' = \{ \langle q, a, p \rangle \mid \langle p, a, q \rangle \in \Delta \} \) наричаме \emph{огледален} na \(\mathcal{A}\). За всяка дума \( w = w_1w_2 \dots w_k \in L(\mathcal{A}) \) е в сила \( w' = w_k \dots w_2w_1 \in L(\mathcal{A'}) \).
\end{definition}

\begin{definition}
	Kраен автомат \( \mathcal{A} = \langle \Sigma, Q, I, F, \Delta \rangle \) е \emph{детерминиран}, ако:

	\begin{itemize}
		\item \( \mathcal{A} \) има единствено начално състояние \(I = \{q_0\}\).
		\item За всяко \( q_1 \in Q \) и символ \( a \in \Sigma \), съществува не повече от едно \( q_2 \in Q \), такова че \( \langle q_1, a, q_2 \rangle \in \Delta \).
	\end{itemize} 

	\noindent Иначе казано, релацията на прехода може да се представи като частична функция \( \delta: Q \times \Sigma \to Q \) и \emph{детерминираните автомати} можем преставим в следния вид \[ \mathcal{A}_D = \langle \Sigma, Q, q_0, F, \delta \rangle \]

	Предимството на \emph{детерминираните автомати} се изразява в това, че могат да разпознават дали дума \( w \) принадлежи на езика на автомата \( L(\mathcal{A}_D) \) за линейно време спрямо дължината ѝ - \( O(|w|) \), но в определени случаи могат да имат експоненциален брой състояния спрямо еквивалентният им недетерминиран автомат.
\end{definition}

\begin{figure}[!htb]
	\centering
	\input{img/dfa.tex}
	\caption{Детерминиран краен автомат}
\end{figure}

\begin{definition}
	Нека \( \mathcal{A}_D = \langle \Sigma, Q, q_0, F, \delta \rangle \) е \emph{детерминиран краен автомат}. \emph{Разширена функция на прехода} \( \delta^*: Q \times \Sigma^* \to Q \) дефинираме индуктивно:

	\begin{itemize}
		\item \( \delta^*(q, \epsilon) = q \)
		\item \( \delta^*(q, aw) = \delta^*(\delta(q, a), w) \), където \( a \in \Sigma, w \in \Sigma^* \)
	\end{itemize}
\end{definition}

\begin{theorem}
	За всеки краен автомат \(\mathcal{A} = \langle \Sigma, Q, I, F, \Delta \rangle \), съществува еквивалентен на него, детерминиран краен автомат \( \mathcal{A}_D \), където \( L(\mathcal{A}) = L(\mathcal{A}_D) \).
	\begin{proof}
		Нека \( \mathcal{A} \) е краен автомат, на който сме премахнали \( \epsilon \)-преходите. Строим \emph{детерминиран краен автомат} \( \mathcal{A}_D = \langle \Sigma, 2^Q, I, F_D, \delta \rangle \), където:
		\begin{itemize}
			\item \( F_D = \{ S \in 2^Q \mid S \cap F \neq \emptyset \} \)
			\item \( \delta(S,a) = \{ q \in Q \mid \exists p \in S : \langle p, a, q \rangle \in \Delta \} \)
		\end{itemize}
		С индукция по дължината на \( w \), ще покажем, че за произволна дума \( w \in \Sigma^* \) твръденията \( \exists i \in I: \langle i, w, p \rangle \in \Delta^* \) и \( p \in \delta^*(I, w)\) са еквивалентни:
		\begin{itemize}
			\item \emph{База}: за \( |w| = 0 \) имаме \( w = \epsilon \). Тогава \( \exists i \in I: \langle  i, \epsilon, i \rangle \in \Delta^* \). Тъй като \( \mathcal{A} \) няма \( \epsilon \)-преходи, то \( \delta^*(I, \epsilon) = I \).
			
			\item \emph{Индукция}: \( w = w'a, a \in \Sigma, |w| = |w'| + 1 \). \newline
			\( (\Rightarrow) \) Нека допуснем, че \( \exists i \in I \), така че \( \langle i, w'a, p \rangle \in \Delta^* \), което значи, че \( \exists p' \in Q: \langle p', a, p \rangle \in \Delta \). По индуктивното предположение знаем, че и \( p' \in \delta^*(I, w') \) и от дефиницията на \( \delta \) следва, че \( p \in \delta(\delta^*(I, w'), a) \). \newline
			\( (\Leftarrow) \) Нека допуснем, че \( p \in \delta^*(I, w'a) \). Тогава \( \exists p': p' \in \delta^*(I, w') \). От индуктиното предположение знаем, че \( \langle i, w', p' \rangle \in \Delta^* \) и от дефинициите на \( \delta  \) и \( \Delta \) следва, че \( \langle p', a, p \rangle \in \Delta \), от където следва, че \( \exists i \in I: \langle i, w'a, p \rangle \in \Delta^* \).
		\end{itemize}
		Така можем да заключим, че за всяка дума \( w \in L(\mathcal{A}) \), \( \exists i \in I, \exists f \in F : \langle i, w, f \rangle \in \Delta^* \) е изпълнено, че \( \delta^*(I, w) \in F_D \), следователно \( w \in L(\mathcal{A}_D) \) и \( L(\mathcal{A}) = L(\mathcal{A}_D) \).
	\end{proof}
\end{theorem}

\subsection{Крайни преобразуватели}

\begin{definition}
	\emph{Краен преобразувател} дефинираме като петорка \( \mathcal{T} = \langle \Sigma_1^* \times \Sigma_2^*, Q, I, F, \Delta \rangle \), където

	\begin{itemize}
		\item \( \Sigma_1, \Sigma_2 \) са \emph{крайни азбуки от символи}
		\item \( Q \) е \emph{крайно множество от състояния}
		\item \( I \subseteq Q \) е \emph{множество от начални състояния}
		\item \( F \subseteq Q \) е \emph{множество от финални състояния}
		\item \( \Delta \subseteq Q \times (\Sigma_1^* \times \Sigma_2^*) \times Q \) е \emph{релация на прехода}
	\end{itemize}
 
	Тройки от вида \( \langle q_1, \langle w, m \rangle, q_2 \rangle \in \Delta \) наричаме \emph{преходи} и казваме, че започва състояние \( q_1 \), има етикет по горната лента \( w \) и по долната лента \( m \) и завършва в състояние \( q_2 \). Алтернативно, тези преходи обозначаваме като \( q_1 \to^w_m q_2 \).
\end{definition}

\begin{definition} 
	Нека \( \mathcal{T} = \langle \Sigma_1^* \times \Sigma_2^*, Q, I, F, \Delta \rangle \) е краен преобразувател. \emph{Път} в \( \mathcal{T} \) наричаме крайна редица от преходи с дължина \( k > 0 \) 
	\[ \pi = q_0 \to^{w_1}_{m_1} q_1 \to^{w_2}_{m_2} \ldots \to^{w_k}_{m_k}  q_k \] 
	където \( \langle q_{i-1}, \langle w_i, m_i \rangle, q_i \rangle \in \Delta \) за \( i = 1 \ldots k \). Казваме, че \emph{пътят} започва от състояние \( q_0 \) и завършва в състояние \( q_k \). Елементите \( q_0,q_1, \ldots ,q_k \) наричаме \emph{състояния на пътя}, а думата \( w = w_1 w_2 \ldots w_k \) наричаме \emph{входна дума} на пътя, а \( m = m_1 m_2 \ldots m_k \) е \emph{изходна дума} на пътя. \newline \emph{Успешен път} в преобразувателя започва от начално състояние и завършва във финално състояние.
\end{definition}

\begin{figure}[!htb]
	\centering
	\input{img/fst.tex}
	\caption{Краен преобразувател}
	\label{fig:Fst}
\end{figure}

\begin{example}
	Нека са зададени азбуки \( \Sigma_1 = \{ a,b,c \}, \Sigma_2 = \{ d,\epsilon \} \) и преобразувател \( \mathcal{T} \) над \( \Sigma_1^* \times \Sigma_2^*\) със състояния \( Q = \{ 0, 1, 2 \} \), начални \( I = \{ 0 \} \), финални \( F = \{ 0 \} \) и релация на прехода \( \Delta = \{ \langle 0, \langle a, d \rangle, 1 \rangle, \langle 1, \langle b, \epsilon \rangle, 0 \rangle, \langle 0, \langle b, d \rangle, 2 \rangle, \langle 2, \langle c, \epsilon \rangle, 0 \rangle \} \). \newline
	\( \mathcal{T} \) е изобразен на Фигура \ref{fig:Fst}. \newline
	\( 0 \to^{b}_{d} 2 \to^{c}_{\epsilon} 0 \to^{a}_{d} 1 \to^{b}_{\epsilon} 0 \) е успешен път, превеждайки думата \emph{bcab} в \emph{dd}.
\end{example}

\begin{definition}
	Нека \( \mathcal{T} = \langle \Sigma_1^* \times \Sigma_2^*, Q, I, F, \Delta \rangle \) е краен преобразувател. \emph{Подлежащ автомат} на \( \mathcal{T} \) дефинираме като \( \mathcal{A} = \langle \Sigma, Q, I, F, \Delta' \rangle \), където \( \Delta' = \{ \langle p, w, q \rangle \mid \langle p, \langle w, m \rangle, q \rangle \in \Delta \}\)
\end{definition}

\subsection{Регулярни езици и релации}

\begin{definition} 
	\emph{Регулярен език} е множество над крайна азбука \( \Sigma \), което дефинираме индуктивно:
	\begin{itemize}
		\item \( \emptyset \) е регулярен език.
		\item ако \( a \in \Sigma \), то \( \{ a \} \) е регулярен език.
		\item ако \( L_1, L_2 \subseteq \Sigma^* \) са регулярни езици, то 
		\begin{itemize}
			\item \( L_1 \cup L_2 \) (обедниение)
			\item \( L_1 \cdot L_2 = \{ a \cdot b \mid a \in L_1, b \in L_2 \} \) (конкатенация)
			\item \( L_1^* = \bigcup_{i=0}^{\infty}L^i \) (звезда на Клини)
		\end{itemize}
		 са също регулярни езици.
		\item Не съществуват други регулярни езици.
	\end{itemize}
	Регулярните езици са също така \emph{затворени} относно операциите \emph{допълнение} (\( \Sigma^* \setminus L_1 \)), \emph{разлика} (\( L_1 \setminus L_2 \)), \emph{обръщане} (\( L_1^{-1} \)) и \emph{сечение} (\( L_1 \cap L_2 \)).
\end{definition}

\begin{definition} 
	\emph{Двоична регулярна стрингова релация} дефинираме индуктивно като множество от двойки над крайни азбуки \( \Sigma_1, \Sigma_2 \):
	\begin{itemize}
		\item \( \emptyset \) е регулярна релация.
		\item Ако \( a \in \Sigma_1 \times \Sigma_2 \), то \( \{ a \} \) е регулярна релация.
		\item Ако \( R_1, R_2 \) са регулярни релации, то:
		\begin{itemize}
			\item \( R_1 \cup R_2 \) (обединение)
			\item \( R_1 \cdot R_2 = \{ a \cdot b \mid a \in R_1, b \in R_2 \} \) (конкатенация)
			\item \( R_1^* = \bigcup_{i=0}^{\infty}R^i \) (звезда на Клини)
		\end{itemize}
		са също регулярни релации.
		\item Не съществуват други регулярни релации.
	\end{itemize}
\end{definition}

\begin{definition}
	Нека \( R_1, R_2, \in \Sigma^* \times \Sigma^* \) са \emph{двоични стрингови релации}. \emph{Конкатенацията} на \( R_1 \) и \( R_2 \) дефинираме както следва
	\[ R_1 \cdot R_2 = \{ \langle u_1 \cdot v_1, u_2 \cdot v_2 \rangle \mid \langle u_1, u_2 \rangle \in R_1, \langle v_1, v_2 \rangle \in R_2 \} \]
\end{definition}

\begin{definition} 
	\emph{Регулярен израз} наричаме дума над крайна азбука \( \Sigma \cup \{ (, ), \vert, * \} \)
	\begin{itemize}
		\item \( \epsilon \) е регулярен израз.
		\item Ако \( a \in \Sigma \), то \( a \) е регулярен израз.
		\item Ако \( E_1, E_2 \) са регулярни изрази, то \( E_1 | E_2 \) и \( E_1 E_2 \), \( E_1^* \) също са регулярни изрази.
		\item Не съществуват други регулярни изрази.
	\end{itemize}
	Всеки регулярен израз има сътветстващ регулярен език:
	\begin{itemize}
		\item \( L(\epsilon) = \emptyset \)
		\item \( L(a) = \{ a \}, a \in \Sigma \)
		\item \( L(E_1 | E_2) = L(E_1) \cup L(E_2) \)
		\item \( L(E_1 E_2) = L(E_1) \cdot L(E_2) \)
		\item \( L(E_1^*) = L(E_1)^* \)
	\end{itemize}
\end{definition}

\begin{example}
	\verb/(a|b)*c/ е \emph{регулярен израз}, разпознаващ думите \emph{c, ac, bc, aac, abc, abbc, bababbc ...}
\end{example}

\begin{theorem}{\emph{(Клини)}}
	За всеки регулярен израз \( E \) съществува краен автомат \( \mathcal{A} \), за който \( L(E) = L(\mathcal{A})\).
\end{theorem}

\begin{theorem}
	Всяка двоична регулярна стрингова релация може да се представи, чрез класически краен преобразувател.
\end{theorem}

\begin{example}
	\( R = \{ \langle ab, d \rangle, \langle bc, d \rangle \}^* \) е \emph{регулярна релация}, която е представена чрез чрез крайния преобразувател \(\mathcal{T}\) на Фигура \ref{fig:Fst}. \newline
	С \emph{dom(R)} бележим домейна на \(R\), който изразяваме чрез \emph{подлежащия автомат} на \( \mathcal{T} \), \( dom(R) =  \{ ab, bc, abab, abbc, bcab \dots \} \). С \emph{range(R)} обозначаваме кодомейна на релацията \( range(R) =  \{ \epsilon, d, dd, ddd, dddd \dots \} \).
\end{example}

\begin{example}
	Нека \(L\) е \emph{регулярен език}. \( Id(L) = \{ \langle w, w \rangle \mid w \in L \}\) е \emph{регулярна релация}.
\end{example}

\begin{definition}
	\emph{Регулярна стрнгова функция} наричаме регулярна стрингова релация, която е частична функция. 
\end{definition}

\subsection{Бимашини}

\begin{definition}
	 \emph{Класическа бимашина} дефинираме като тройка \( \mathcal{B} = \langle \mathcal{A}_L, \mathcal{A}_R, \psi \rangle \), където

	\begin{itemize}
		\item \( \mathcal{A}_L = \langle \Sigma, Q_L, s_L, Q_L, \delta_L \rangle \) и \( \mathcal{A}_R = \langle \Sigma, Q_R, s_R, Q_R, \delta_R \rangle \) са \emph{детерминирани крайни автомати} и ги наричаме съответно \emph{ляв и десен автомат} на бимашината. Всички състояния на тези автомати са финални.
		\item \( \psi:(Q_L \times \Sigma \times Q_R) \to \Sigma^* \) e частична функция, която наричаме \emph{изходна функция}.
	\end{itemize}
\end{definition}

\begin{definition} 
	Нека \( \mathcal{B} = \langle \mathcal{A}_L, \mathcal{A}_R, \psi \rangle \) е класическа бимашина, \( \Sigma \) е азбуката на на автоматите \( \mathcal{A}_L \) и \( \mathcal{A}_R \) и \( w = a_1a_2 \dots a_k \in \Sigma^* \) \( (k \geq 0) \) е дума и \( a_i \in \Sigma \) \( (1 \leq i \leq k) \) са букви. Ако \( \delta_L^*(a_1a_2 \ldots a_k) \) и \( \delta_R^*(a_ka_{k-1} \dots a_1) \) са дефинирани, то можем да получим двата пътя:
	\[ \pi_L = l_0 \to^{a_1} l_1 \to^{a_2} \ldots l_{k-1} \to^{a_k} l_k \]
	\[ \pi_R = r_0 \leftarrow^{a_1} r_1 \leftarrow^{a_2} \ldots r_{k-1} \leftarrow^{a_k} r_k \]
	Където \( \pi_L \) и \( \pi_R \) са пътища в съответно левия и десния автомат и думата \( w \) се разпознава от \( \mathcal{A}_L \) в посока от ляво на дясно, а от \( \mathcal{A}_R \), съответно от дясно на ляво. Ако за всички тройки \( \langle l_{i-1}, a_i, r_i \rangle \), изходната функция \( \psi(l_{i-1}, a_i, r_i) \) е дефинирана, то двойката пътища \( \langle \pi_L, \pi_R \rangle \) наричаме \emph{успешно изпълнение} на \( \mathcal{B} \) с етикет \( w = a_1a_2 \dots a_k \) и \emph{изход}
	\[ \mathcal{O_B}(w) = \psi(l_0, a_1, r_1) \cdot \psi(l_1, a_2, r_2) \cdot \dots \cdot \psi(l_{k-1}, a_k, r_k) \]
	\( \mathcal{O_B} \) наричаме \emph{изходна функция на бимашината} и казваме, че бимашината \emph{превежда} \(w\) в \(m\), ако \( \mathcal{O_B}(w) = m \), където \(m\) е резултат от конкатенацията на всички \( \psi(l_{i-1}, a_i, r_i) \) \( (1 \leq i \leq k) \).
\end{definition}

\noindent Бимашината чете входната дума и за всеки символ извежда дума над азбуката си. На всяка стъпка изведената от изходната функция \( \psi \) дума зависи от входния символ и двете състояния в които биха преминали левият и десният автомат, четейки входа съответно от ляво на дястно и от дясно на ляво. Крайният резултат е конкатенацията на всички така изведени думи.

\begin{definition}
	Нека \( \mathcal{B} = \langle \mathcal{A}_L, \mathcal{A}_R, \psi \rangle \) е бимашина. \emph{Разширената изходна функция \( \psi^* \)} дефинираме индуктивно:

	\begin{itemize}
		\item \( \psi^*(l, \epsilon, r) = \epsilon \) за всяко \( l \in Q_L, r \in Q_R \)
		\item \( \psi^*(l, wa, r) = \psi^*(l, w, \delta_R(r, a)) \cdot \psi(\delta^*_L(l, w), a, r) \), за \( l \in Q_L, r \in Q_R, w \in \Sigma^*, a \in \Sigma \)
	\end{itemize}
\end{definition}

\begin{figure}[!htb]
	\centering
	\includegraphics[
		width=12cm,
		height=6cm,
		keepaspectratio,
	  ]{img/bm.png}
	\caption{Бимашина представяща \( \{ \langle ab, d \rangle, \langle bc, d \rangle \}^* \)}
	\label{fig:Bm}
\end{figure}

\begin{example}{\emph{(Бимашина и изпълнение)}}
	Нека разлгледаме бимашината на Фигура \ref{fig:Bm}. Задаваме входна дума \emph{bcabbc}, което води до следното изпълнение на левия и десния автомат съответно.

	\[ \pi_L = 0 \to^{b} 2 \to^{c} 0 \to^{a} 1 \to^b 0 \to^{b} 2 \to^{c} 0 \]
	\[ \pi_R = 0 \leftarrow^{b} 2 \leftarrow^{c} 0 \leftarrow^{a} 1 \leftarrow^{b} 0 \leftarrow^{b} 2 \leftarrow^{c} 0 \]

	Изходната функция на бимашината \(\mathcal{O_B} \) прилагаме както следва:
	\[
		\psi(0,b,2) \cdot \psi(2,c,0) \cdot \psi(0,a,1) \cdot \psi(1,b,0) \cdot \psi(0,b,2) \cdot \psi(2,c,0) =
	d \cdot \epsilon \cdot d \cdot \epsilon \cdot d \cdot \epsilon = ddd
	\]

\end{example}

\begin{definition}
	Бимашина \( \mathcal{B} = \langle \mathcal{A}_L, \mathcal{A}_R, \psi \rangle \) наричаме \emph{тотална}, ако функциите на прехода \( \delta_L: Q_L \times \Sigma \to Q_L \) и \( \delta_R: Q_R \times \Sigma \to Q_R \) на левия и десния автомат съответно, както и функцията на изхода \( \psi: (Q_L \times \Sigma \times Q_R) \to \Sigma^* \) са \emph{тотални}.
\end{definition}

\begin{theorem}
	Класическите бимашини са еквивалентни по изразителност на регулярните функции. \cite{Schutzenberger:61} \cite{GerdjikovEtAl:2017}
\end{theorem}

\pagebreak
\section{Правила за заместване}

За двоичните стрингови релации можем да си мислим като множество от преводи, като на пример за двойката \( \langle u, v \rangle \) казваме, че думата \( u \) се превежда като \( v \).

\begin{definition}
	\emph{Правило за заместване} представяме във вида
	\[ E \to \beta \]
	където \( E \) е регулярен израз над крайна азбука \( \Sigma \), а \( \beta \in \Sigma^* \) е дума.
	\emph{Приложение на правилото върху текст} \( t \in \Sigma^* \) представлява заместването на поднизовете на \( t \), които са в езика \( L(E) \) с \( \beta \).
\end{definition}

\begin{figure}[!htb]
	\centering
	\begin{tikzpicture}
		\node[font=\Large] {
			\( a_1a_2 \dots a_i \dots a_{i+k} \dots a_{j} \dots a_{j+l} \dots a_n \)
		};
		\draw [decorate,decoration={brace,amplitude=5pt,raise=0pt},yshift=0pt]
		(-2.75,0.4) -- (-0.25,0.4) node [black,midway,xshift=0cm,yshift=0.5cm] {\footnotesize $ \in L(E) $};
		\draw [decorate,decoration={brace,amplitude=5pt,mirror,raise=0pt},yshift=0pt]
		(-2.75,-0.3) -- (-0.25,-0.3) node [black,midway,xshift=0cm,yshift=-0.5cm] {\footnotesize $ \beta $};
		\draw [decorate,decoration={brace,amplitude=5pt,raise=0pt},yshift=0pt]
		(0.8,0.4) -- (3.15,0.4) node [black,midway,xshift=0cm,yshift=0.5cm] {\footnotesize $ \in L(E) $};
		\draw [decorate,decoration={brace,amplitude=5pt,mirror,raise=0pt},yshift=0pt]
		(0.8,-0.3) -- (3.15,-0.3) node [black,midway,xshift=0cm,yshift=-0.5cm] {\footnotesize $ \beta $};
	\end{tikzpicture}
	\caption{Приложение на правило на заместване}
\end{figure}

\noindent \emph{Правила за заместване} можем да представим като \emph{регулярни стрингови релации}, използвайки единствено алгебрата на регулярните езици и релации. Те се реализират програмно чрез крайни преобразуватели. \cite{Kaplan&Kay:94}

\begin{definition}
	Нека разгледаме текст \( t \in \Sigma^* \). \emph{Kонтекст на заместване} наричаме тройка \( \langle u,v,w \rangle \), където \( t = uvw \). Също така \( u \) и \( w \) наричаме съответно \emph{префикс} и \emph{суфикс} на контекста, докато \( v \) наричаме \emph{фокус}.
\end{definition}

\begin{example}
	Нека разгледаме правилото \verb/ab|bc/ \( \to d \). След приложението му над текста \emph{abb}, ще получим \emph{db}, като \( \langle \epsilon, ab, b \rangle \) е единственият контекст на заместване. Приложението на правилото над \emph{abbacbca} ще доведе до \emph{dbacda} с два контекста на заместване \( \langle \epsilon, ab, bacbca \rangle \) и \( \langle abbac, bc, a \rangle \).
\end{example}

\subsection{Разрешаване на многозначности}

При прилагане на правило за заместване могат да възникнат многозначности в случаите, в които два контекста имат застъпващи се фокуси.

\begin{definition}
	Два контекста на заместване \( \langle u_1,v_1,w_1 \rangle \) и \( \langle u_2,v_2,w_2 \rangle \) за даден текст \( t \) \emph{се застъпват}, ако \( u_1 < u_2 < u_1v_1 \). Израза \( u_1 < u_2 \) четем като \( u_1 \) е \emph{префикс} на \( u_2 \).
\end{definition}

\begin{figure}[!htb]
	\centering
	\input{img/ctxoverlap1.tex}
	\caption{Застъпващи се контексти}
\end{figure}

\begin{example}
	Нека разгледаме правилото \verb/ab|bc/ \( \to d \) приложено над текста \( t = aabcb \). Получаваме контекстите \( \langle a, ab, cb \rangle \) и \( \langle aa, bc, b \rangle \), които очвевидно се застъпват и съответно стигаме до две различни валидни замествания \emph{adcb} и \emph{aadb}.
\end{example}

\begin{figure}[!htb]
	\centering
	\input{img/ctxoverlap2.tex}
	\caption{Застъпващи се контексти с еднакво начало}
\end{figure}

\begin{example}
	Друг вид многозначност може да получим, когато фокусите на два контекста имат еднакво начало. Например, ако приложим правилото \(a+ \to d \) над тескт \( t = aa \), може получим превода \emph{dd}, на който отговарят контекстите \( \langle a, a, \epsilon \rangle \) и \( \langle \epsilon, a, a \rangle \), и \emph{d} с контекст \( \langle \epsilon, aa, \epsilon \rangle \).
\end{example}
%%
\begin{definition}\label{def:LmlOps}
	Въвеждаме следните оператори над множества от контексти:
\[ AFTER(A, B) = \{ \langle u, v, w \rangle \in A \mid \forall \langle u', v', w' \rangle \in B : u' \cdot v' \leq u \land u' < u  \} \] 

\( AFTER \) избира измежду всички контексти в множеството \(A\) тези, в които фокусът \(v\) започва след всички фокуси в множеството \(B\).

\[ LEFTMOST(A) = \{ \langle u, v, w \rangle \in A \mid \forall \langle u', v', w' \rangle \in A : u \leq u' \} \]

\( LEFTMOST \) избира измежду всички контексти в \(A\), тези с чийто фокус се намира възможно най в ляво. Може да имаме повече от един такъв контекст.

\[ LONGEST(A) = \{ \langle u, v, w \rangle \in A \mid \forall \langle u', v', w' \rangle \in A : u \neq u' \lor v' \leq v \} \]

Измежду контекстите, чиито фокуси започват от една и съща позиция, \( LONGEST \) избира тези, които имат най-дълъг фокус.
\end{definition}

\begin{definition}
	Въвеждаме оператора \( LML(A) \) (leftmost-longest), чрез който ще елиминираме многозначностите. По дадено множество от контексти \(A\), \( LML(A) \) избира най-левите, най-дълги измежду тях.

	\[ LML(A) := \bigcup\limits_{i=0}^{\infty} C_{i} \]

	Където междинните множества \( C_i \) строим по индукция:

	\[ C_0 = \emptyset \]
	\[ C_{i+1} = C_i \cup LONGEST(LEFTMOST(AFTER(A, C_i))) \]

	\noindent \( LML(A) \) е крайно множество, защото \( A \) е крайно, т.е. след дадем момент редицата ще престане да нараства.
\end{definition}

\begin{proposition}
	Нека \( t \in \Sigma^* \) е текст и \(A\) е множество от контексти в \(t\). \( LML(A) \) съдържа само незастъпващи се контексти.

	\begin{proof}
		Нека \( LML(A) \) съдържа застъпващите се контексти \( \langle u_1, v_1, w_1 \rangle \) и \( \langle u_2, v_2, w_2 \rangle \) т.е. \( u_1 < u_2 < u_1v_1 \). Също така \( \langle u_1, v_1, w_1 \rangle \in C_{i_1} \) и \( \langle u_2, v_2, w_2 \rangle \in C_{i_2} \). Нека допуснем, че \( i_1 \geq i_2 \). В такъв случай:
		\[ \langle u_2, v_2, w_2 \rangle \in C_{i_2} = C_{i_2-1} \cup LONGEST(LEFTMOST(AFTER(A, C_{i_2-1}))) \]

		\noindent След като \( \langle u_2, v_2, w_2 \rangle \notin C_{i_2-1} \), то \( \langle u_2, v_2, w_2 \rangle \in LEFTMOST((AFTER(A, C_{i_2-1})) \).
		От допускането, че \( i_1 \geq i_2 \) следва, че \( \langle u_1, v_1, w_1 \rangle \in AFTER(A,C_{i_2-1}) \), което е в противоречие с дефиницията на \( LEFTMOST \) и следователно \( i_1 < i_2 \).

		\noindentСлед като \( i_1 < i_2 \), то \( \langle u_2, v_2, w_2 \rangle \notin C_i \) за \( i \leq i_1 \). При \( i > i_1 \), \( \langle u_1, v_1, w_1 \rangle \in C_i \), значи \( \langle u_2, v_2, w_2 \rangle \in AFTER(A, C_i) \), което не е възможно спрямо дефиницията на \( AFTER \) т.е. \( \langle u_2, v_2, w_2 \rangle \notin C_{i+1} \). Това противоречи с факта, че \( \langle u_2, v_2, w_2 \rangle \in C_{i_2} \) \( (i_1 < i_2) \), следователно \( LML(A) \) не съдържа застъпващи се контексти.
	\end{proof}
\end{proposition}

\begin{definition}
	Нека \( T \subseteq \Sigma^* \times \Sigma^* \) е релация и \( t \in \Sigma^* \) е текст. С \( A_{dom(T)} \) бележим множеството на всички поднизове в \(t\), които са в \(dom(T)\). Нека \[ t = u_1 v_1 x_2 v_2 \dots x_k v_k w_k \] е каноничното представяне на \(t\) за множеството \( LML(A_{dom(T)}) \). Тогава \(t'\) е \emph{заместването} на \(t\) с \(T\) под стратегията най-ляво-най-дълго срещане \[t = u_1 v_1' x_2 v_2' \dots x_k v_k' w_k\] и \( \langle v, v' \rangle \in T \) за \( 1 \leq i \leq k \). С \( R^{LML}(T) \) бележим релацията на заместване под стратегията най-ляво-най-дълго срещане за \(T\). Тя съдържа всички двойки \( \langle t, t' \rangle \in \Sigma^* \times \Sigma^* \), така че \( t' \) е заместване на \( t \) с \(T\) под стратегията най-ляво-най-дълго срещане.
\end{definition}

\begin{corollary}
	Нека \( T: \Sigma^+ \to \Sigma^* \) е функция, тогава релацията на заместване \( R^{LML}(T) \) е функционална.
\end{corollary}

\begin{example}
	Нека разгледаме правилото \verb/ab|bc/ \( \to d \) съответстващо на релацията \(T = \{ \langle ab,d \rangle, \langle bc, d \rangle \} \), приложено над текста \( t = aabcbab \). Получаваме контекстите \( \langle a, ab, cbab \rangle \), \( \langle aa, bc, bab \rangle \) и \( \langle aabcb, ab, \epsilon \rangle \). Очевидно първите два се застъпват, но стратегията най-ляво-най-дълго срещане определя първият и третият за валидни. Резултатът от заместането е \( R^{LML}(T)(aabcbab) = adcbd \).
\end{example}

\pagebreak
\subsection{Лексически анализ чрез регулярни релации}
\label{sec:LexARegRel}
Регулярните релации намират своето приложение в множество домейни, като лексическият анализ е един от тях. Идеята е да сведем процеса на токенизация до заместване на думи в текст, като от граматиката построим релация назаместване под стратегията най-ляво-най-дълго срещане. Тази релация реализираме програмно чрез краен преобразувател. Той поставящ маркери преди и след всяка разпозната лексема. В последствие по този преобразувател строим еквивалентна бимашина \cite{GerdjikovEtAl:2017}.

Ще представим формално конструкция на релация на заместване под стратегията най-ляво-най-дълго срещане, следвайки алгоритъма на Карттунен (1996) \cite{Karttunen:96}. Целта ни е по задада регулярна релация \(T\), да получим \( R^{LML}(T) \). В последствие ще използваме тази конструкция, за да построим релация за лексически анализ.

Като начало дефинираме множеството на маркерите, които ще използваме за извършване на заместването - \( \{ cb, lb, rb \} \). Това са произволни символи извън входната азубука на \(T\), \( \Sigma \cap \{ cb, lb, rb \} = \emptyset \). Множеството на всички символи бележим със \( \Sigma_x = \Sigma \cup \{ cb, lb, rb \} \). 

\begin{definition}
	Представяме следните функции над регулярни езици:
	\[ not(L) = \{ w \mid w \in \Sigma_x^* \land w \notin L \} \]
	\[ contain(L) = \{ w \mid w_1w_2w_3 = w: w_1, w_3 \in \Sigma_x^* \land w_2 \in L \} \]
	С \( not(L) \) получаваме допълнението на езика \(L\), \( contain(L) \) връща езика, който се състои от всички думи, които съдържат инфикс в \(L\). Строим функциите по следния начин:
	\[ not(L) := \Sigma_x^* \setminus L \]
	\[ contain(L) := \Sigma_x^* \cdot L \cdot \Sigma_x^* \]
\end{definition}

\begin{definition}
	Представяме групата от оператори \(intro\), въведени от Каплан и Кей (1994) \cite{Kaplan&Kay:94}:
	\[ intro(S) := (Id(\Sigma_x \setminus S) \cup (\{\epsilon\} \times S))^* \]
	\[ introx(S) := (intro(S) \cdot Id(\Sigma_x \setminus S)) \cup \{\epsilon\} \]
	\[ xintro(S) := (Id(\Sigma_x \setminus S) \cdot intro(S)) \cup \{\epsilon\} \]
	\emph{intro(S)} създава релация, която добавя произволно символи от \(S\) в думи, които не съдържат символи от \(S\), \emph{introx(S)} и \emph{xintro(S)} са аналогични, като символите от \(S\) не могат да бъдат съответно в края и началото на изходната дума.
\end{definition}

\begin{example}
	Имаме регулярният език \( \{a,b\} \), в който \emph{въвеждаме} символите от \(S := \{ x \}\). Тогава релацията \(intro(S)\) ще съдържа двойките \( \langle b, xb \rangle, \langle ab, axbx \rangle, \langle abba, axxbbax \rangle \dots \) и т.н.
\end{example}

\begin{definition}
	Преставяме групата от \emph{ignore} оператори \cite{Kaplan&Kay:94} както следва:
	\[ ign(L,S) := range(Id(L) \circ intro(S)) \]
	\[ ignx(L,S) := range(Id(L) \circ introx(S)) \]
	\[ xign(L,S) := range(Id(L) \circ xintro(S)) \]
	По даден регулярен език \(L\) и множество от символи \(S\), \emph{ign(L,S)} връща регулярен език, който се състои от думите в \(L\), с включени символи от \(S\). \emph{ignx(L,S), xign(L,S)} са аналогични като не включват символи от \(S\) съответно в края и в началото на думите.	
\end{definition}

\begin{example}
	Нека разгледаме регулярният език \(L(E)\), съответстващ на израза \( E = \verb/(a|b)+/ \). Този език се състои от всички думи с дължина поне един символ, които съдържат произволен брой \emph{'a'} и \emph{'b'}. \( L(E) = \{a, b, ba, ab, ababb \dots \} \), \( ign(L(E), \{x\}) \) ще съдържа думите \emph{ab, xa, xab, xabxxb, bbb, bxabx \dots }.
\end{example}

\begin{definition}\label{def:defIfPThenS}
	Въвеждаме следните функции, които строят филтриращи автомати по зададени регулярни езици \cite{Kaplan&Kay:94}:
	\[ ifPthenS(P,S) = \{ w \mid \forall w_1w_2 = w: w_1 \in P \to w_2 \in S \} \]
	\[ ifSthenP(P,S) = \{ w \mid \forall w_1w_2 = w: w_2 \in S \to w_1 \in P \} \]
	\emph{ifPthenS(P,S)} дефинира езика, който включва всички думи, на чиито думи, ако префиксите им са в \(P\) то суфиксите са в \(S\). Аналогично \emph{ifSthenP(P,S)} представя думите, за които ако всичките им суфикси са в \(S\), то префиксите им са в \(P\). Реализираме тези функции както следва:
	\[ ifPthenS(P,S) := not(P \cdot not(S)) \]
	\[ ifSthenP(P,S) := not(not(P) \cdot S) \]	
\end{definition}

\begin{definition}
	Комбинираме операторите от дефиниция \ref{def:defIfPThenS}, за да представим:
	\[ PiffS(P,S) = \{ w \mid \forall w_1w_2 = w: w_1 \in P \leftrightarrow w_2 \in S \} \]
	\[ LiffR(L,R) = \{ w \mid \forall w_1w_2w_3 = w: \forall w_2'w_2'' = w_2: w_2' \in L \leftrightarrow w_2'' \in R \} \]
	\emph{PiffS(P,S)} строи автомат, разпознаващ думите, чиито префикси са в \(P\) тогава и само тогава, когато суфиксите им са в \(S\). \emph{LiffR(L,R)} съдържа думите \( w = w_1w_2w_3 \), така че префиксите на \(w_2\) са в \(L\) и суфиксите на \(w_2\) са в \(R\). Реализираме тези функции както следва:
	\[ PiffS(P,S) := ifPthenS(P,S) \cap ifSthenP(P,S) \]
	\[ LiffR(L,R) := PiffS((\Sigma_x^* \cdot L), (R \cdot \Sigma_x^*)) \]	
\end{definition}

\begin{definition}\label{def:Robl}
	Нека \(T \subseteq \Sigma^* \times \Sigma^* \) е регулярна релация. \emph{Релацията на задължително заместване} \(R^{obl}(T)\) дефинираме както следва:
	\[ R^{obl}(T) := N(T) \cdot (T \cdot N(T))^* \]
	\[ N(T) = Id(\Sigma^* \setminus (\Sigma^* \cdot dom(T) \cdot \Sigma^*)) \cup \{ \langle \epsilon, \epsilon \rangle \} \]
	\(N(T)\) е идентитета на множеството от всички думи, които не съдържат инфикси в \(dom(T)\) обединен с двойката \(\langle \epsilon, \epsilon \rangle\), заместваща празната дума с празната дума.
	Идеята е следната - поддумите от входната дума, които са в домейна на релацията \(T\) се превеждат спрямо \(T\), докато тези, които не са в домейна ѝ се превеждат чрез идентитет, т.е. входът там остава непроменен.
\end{definition}

\begin{proposition}
	Нека е дадена регулярната релация \(T\) и построената по нея релация на задължително заместване \(R^{obl}(T)\). \(N(T)\) е следва дефиниция \ref{def:Robl}. Нека \(t, t' \in \Sigma^*\) и \( \langle t, t' \rangle \in R^{obl}(T) \), тогава и само тогава, когато съществуват следните декомпозиции:
	\[ t = u_0 v_1 u_1 \dots v_n u_n \]
	\[ t' = u_0 v_1' u_1 \dots v_n' u_n \]
	за които е изпълнено, че \( u_0, u_i \in dom(N(T)), v_i \in dom(T) \) и \( \langle v_i, v_i' \rangle \in T \).
\end{proposition}

\begin{example}
	Нека разгледаме следния пример: \(T = \{ \langle ab, d \rangle, \langle bc, d \rangle \} \) и имаме \(R^{obl}(T) \). Входният текст \( t_1 = babacbca \) се декомпозира като:
	\[ t_1 = b \cdot ab \cdot ac \cdot bc \cdot a \]
	Сегментите \(\{b, ac, a\} \in dom(N(T))\), докато \(\{ab, bc\} \in dom(T)\). Съответно след заместването получаваме
	\[ t_1' = b \cdot d \cdot ac \cdot d \cdot a \]
	За входният текст \( t_2 = abcc \) обаче имаме две валидни композиции:
	\[ t_2 = ab \cdot cc = a \cdot bc \cdot c \]
	Това ще доведе до два възможни превода, т.е. \( \langle abcc, dcc \rangle \in R^{obl}(T) \) и \( \langle abcc, adc \rangle \in R^{obl}(T) \).
\end{example}

Вече сме готови да дефинираме основните релации. Започваме с тази за първоначално срещане.

\begin{definition}\label{def:Rinit} \emph{Релация на първоначално срещане} представяме както следва:
	\[ R^{init}(T) := intro(\{ cb \}) \circ Id(LiffR(\{ cb \}, xign(dom(T), \{ cb \}))) \]

	\( R^{init}(T) \) поставя маркерa \verb/cb/ в началото на всяко срещане на поддума (фокус) от входния текст, която е в домейна на \(T\). Тази стъпка отговаря на оператора \(AFTER\) (дефиниция \ref{def:LmlOps}) и идентифицира всички контексти на заместване в текста независимо от това дали се застъпват, или са с възможно най-дълги фокуси. 
\end{definition}

\begin{definition}\label{def:Rleft} \emph{Релация на най-ляво срещане} представяме както следва:
	\[ R^{left}(T) := (((Id(\Sigma^*) \cdot \{ \langle cb, lb \rangle \} \cdot Id(ignx(dom(T), \{ \langle \epsilon, rb \rangle \})))^*) \cdot Id(\Sigma^*)) \circ R_{obl} (\Sigma_x, \{ \langle cb, \epsilon \rangle \}) \]
	\(R^{left}(T)\) получава текст с маркерите (\verb/cb/) от първатата стъпка (\(R^{init}(T)\)) и поставя в началото и края на всеки контекст маркерите \verb/lb/ и \verb/rb/, като  \verb/cb/ се замества с \verb/lb/. Между маркерите за начало и край, не може да съществуват други маркери. Това може да доведе до повече от един изходен текст. Тази стъпка отговаря на оператора \(LEFTMOST\) (дефиниция \ref{def:LmlOps}) и осигурява, че измежду контекстите със застъпващи се фокуси, ще останат тези с най-ляв фокус.
\end{definition}

\begin{definition}\label{def:Rlong} \emph{Релация на най-дълго срещане} представяме както следва:
	\[ R^{long}(T) := Id(not(contain(\{lb\} \cdot (ignx(dom(T), \{lb, rb\}) \cap contain(\{rb\}))))) \]
	Релацията получава изхода от втората съпка (\(R^{left}(T)\)) и измежду маркираните текстове съдържащи контексти с еднакво начало, извежда такъв, в който фокусите са най-дълги. Тази стъпка отговаря на оператора \(LONGEST\).
\end{definition}

\begin{definition}\label{def:Rreplace} \emph{Релация на заместване} представяме както следва:
	\[ R^{replace}(T) := R^{obl}(\Sigma_x, \{ \langle lb, \epsilon \rangle \} \cdot T \cdot \{ \langle rb, \epsilon \rangle \}) \]
	В тази стъпка получаваме изходния текст на \(R^{long}\), в който поддумите в домейна на преобразувателя са маркирани с \verb/lb/ и \verb/rb/ под стратегията най-ляво-най-дълго срещане. Този преобразувател извършва заместването на тези поддуми чрез входния преобразувател и премахва всички маркери.
\end{definition}

\begin{definition} \emph{Релация на заместване под стратегията "най-ляво-най-дълго срещане"} получаваме като композираме релациите дефинирани в \ref{def:Rinit}, \ref{def:Rleft}, \ref{def:Rlong}, \ref{def:Rreplace} , които строим независимо една от друга.

\[ R^{LML}(T) = R^{init}(T) \circ R^{left}(T) \circ R^{long}(T) \circ R^{replace}(T) \]
\end{definition}

\begin{example}
	Имаме релациите \( R_1, R_2 \), съответстващи на правилата на заместване \verb/ab+/ \( \to x \) и \verb/bc/ \( \to y \). \(R_1\) замества думите, започващи с \emph{a}, последвано от едно, или повече \emph{b} с \emph{x}. \(R_2\) замества думата \emph{bc} с \emph{y}. Релацията \(T\) получаваме като ги обединим: \( T := R_1 \cup R_2 \). Входният текст е \emph{abcabbdbc} и маркерите \verb/cb/, \verb/lb/ и \verb/rb/ представяме съответно чрез символите \textasciicircum, < и >. Симулираме процеса на заместване както следва:
	\begin{enumerate}
		\item Маркираме началото на всички фокуси в думата: \\ \( R^{init}(T)(abcabbdbc) = \) \emph{\textasciicircum a\textasciicircum bc\textasciicircum abbd\textasciicircum bc}
		\item Идентифицираме най-левите незастъпващи се контексти, което води до следните възможно декомпозиции: \\ 
		\( \langle a\textasciicircum bc\textasciicircum abbd\textasciicircum bc,\) \emph{<ab>c<ab>bd<bc>} \(\rangle \in R^{left}(T) \) \\
		\( \langle a\textasciicircum bc\textasciicircum abbd\textasciicircum bc,\) \emph{<ab>c<abb>d<bc>} \(\rangle \in R^{left}(T) \)
		\item Релацията за най-дълго срещане филтрира думите, чиито маркери не следват съответното изискване: \\
		<ab>c<ab>bd<bc> \( \notin dom(R^{long}(T)) \) \\
		\( R^{long}(T)(\)<ab>c<abb>d<bc>\() = \) <ab>c<abb>d<bc>
		\item Заместваме поддумите спрямо входния преобразувател и получаваме : \\
		\( R^{long}(T)(\)<ab>c<abb>d<bc>\() = xcxdy \)
	\end{enumerate}
\end{example}

\begin{definition} Нека е дадена лексическа граматика
	\[ G := \{ E_1, E_2 \dots E_n \} \]
	където \( E_i, i \in [1, n] \) са регулярни изрази. С \emph{SoT, EoT} са символи, с които съответно маркираме началото и края на лексемите във входния текст. \emph{Релацията за лексически анализ} \(R^{lex}\) по зададената граматика \(G\) получаваме както следва:
	\[ T := \bigcup_{i=1}^{|G|} \{ \langle \epsilon, i \cdot SoT \rangle \} 	\cdot Id(L(E_i)) \cdot \{ \langle \epsilon, EoT \rangle \} \]
	\[ R^{lex} := R^{LML}(T) \]
\end{definition}

\begin{figure}[!htb]
	\begin{center}
		\begin{tabular}{ |l|l| }
		\hline
		\textbf{Token} & \textbf{Description} \\
		\hline
		\( E_1 \) & \verb/[0-9]+(\.[0-9]+)?/ \\
		\( E_2 \) & \verb/+|-|*|// \\
		\( E_3 \) & \verb/=/ \\
		\hline
		\end{tabular}
	\end{center}
	\caption{Лексическа граматика на аритметичен израз}
	\label{fig:ArGram}
\end{figure}

\begin{example}
	Нека разгледаме лексическата граматика на Фигура \ref{fig:ArGram}, по която сме построили релация за лексически анализ \(R^{lex}\). За входен текст \(t = 99.9+5 \), ще изведем следния резултат:
	\[ R^{lex}(\emph{99.9+5}) = \verb/"1 SoT 999 ЕоТ 2 SoT + ЕоТ 1 SoT 5 ЕоТ"/ \]
	Изходният текст се състои от сегменти за всеки тоукън, които са във вида \\ \emph{<type-index> SoT <token-text> EoT}.
\end{example}

\begin{proposition}
	Ако релацията \(T\) е функция, то \(R^{LML}(T)\) също е функция.
\end{proposition}

\pagebreak
\section{Реализация}

\subsection{Дизайн}

Реализацията на генератор за лексически анализ чрез бимашина е разделена на четири етапа:

\begin{enumerate}
	\item Конструкция на краен автомат по регулярен израз.
	\item Конструкция на преобразувател по стратегията най-ляво-най-дълго срещане.
	\item Превръщане на функционален преобразувател в еквивалентна бимашина.
	\item Алгоритъм за лексически анализ чрез симулация на бимашина.
\end{enumerate}

\begin{figure}[!htb]
	\centering
	\includegraphics[
		width=14cm,
		keepaspectratio,
	  ]{img/architecture.png}
\end{figure}

В първата част ще представим разширен синтаксис на регулярен израз и разработка на recursive descent парсър, чрез който строим еквивалентния краен автомат. Във втората част ще разгледаме как се строи преобразувател от правила на заместване по стратегията най-ляво-най-дълго срещане и съответно как се строи бимашина по такъв преобразувател. Конструкцията на преобразувателя се съставя изцяло от операции над регулярни езици и релации. В третата част ще видим как се осъществява лексически анализ, чрез получената бимашина.

\subsection{От регулярен израз към краен автомат}

Регулярните изрази датират още от 50'те години на 20'ти век и са интегрирани в стандартните библиотеки на всички модерни езици за програмиране. Съществуват различни стандарти за представянето им, като тук ще ползваме синтаксис сходен с този на регулярните изрази в Perl. 
На Фигура \ref{fig:RegExSyntax} са представени базовите синтактични единици, чрез които конструираме регулярните изрази.

\begin{figure}[!htb]
	\begin{center}
		\begin{tabular}{ |l|l| } 
		\hline
		Израз & Пояснение \\
		\hline
		\verb/ab/ & конкатенация на символите 'a' и 'b' \\
		\verb/|/ & обединение (\verb/A|B/ - думата се разпознава от \verb/A/ или \verb/B/) \\
		\verb/*/ & 0 или повече срещания (Звезда на Килни) \\
		\verb/+/ & 1 или повече срещания \\
		\verb/?/ & 0 или 1 срещане \\
		\verb/./ & всеки символ от азбуката \\
		\verb/(...)/ & начало и край на група (разпознава израза в скобите) \\
		\verb/[...]/ & множество от символи (\verb/[0-9]/ разпознава цифрите от 0 до 9) \\
		\verb/[^...]/ & отрицание (разпознава символите, които не са в множеството) \\
		\verb/{n}/ & точно n на брой срещания \\
		\verb/{n,}/ & поне n на брой срещания \\
		\verb/{n,m}/ & от n до m на брой срещания \\
		\verb/\/ & буквална интерпретация на символ (\verb/\*/ разпознава '*') \\
		\hline
		\end{tabular}
	\end{center}
	\label{fig:RegExSyntax}
	\caption{Синтаксис на регулярен израз}
\end{figure}

\begin{example}
	Нека разгледаме няколко примерни регулярни израза спрямо описания синтаксис.
	\begin{itemize}
		\item \verb/(a|b)*c/ - разпознава думите, които се състоят от 0 или повече символи 'a' и 'b' и завършват на 'c' като на пример: \emph{ac, bc, abbabac, bbac, c, ...}
		\item \verb/.*true.*/ - думите, които съдържат "true": \emph{abctrue, 1true2_, true, ...}
		\item \verb/[a-zA-Z0-9@]+/ - разпознава думите, които се състоят единствено от латински букви, цифри и '@': \emph{z, 1b@, AbC123, 404, ccC, ...}
		\item \verb/[^ \t\r\n]/ - разпознава всички символи, които не са интервал, табулация или нов ред.
	\end{itemize}
\end{example}

За да построим краен автомат по регулярен израз е нужно първо да дефинираме граматическата му структура. Въвеждаме следната безконтекстна граматика на регулярен израз:

\begin{grammar}
	<expr> ::= <term>
	\alt <term> '|' <expr>

	<term> ::= <factor>
	\alt <factor> <term>

	<factor> ::= <atom>
	\alt <atom> <meta-char>
	\alt <atom> '\{' <char-count> '\}'

	<atom> ::= <char>
	\alt '.'
	\alt '(' <expr> ')'
	\alt '[' <char-class> ']'
	\alt '[' '\^{}' <char-class> ']'

	<char-class> ::= <char-class-item> 
	\alt <char-class-item> <char-class>

	<char-class-item> ::= <char> 
	\alt <char> '$-$' <char>

	<char-count> ::= <integer> 
	\alt <integer> ',' 
	\alt <integer> ',' <integer>

	<integer> ::= <digit> 
	\alt <digit> <integer>

	<char> ::= \emph{anyCharExceptMeta}
	\alt '\textbackslash' <any-char>

	<any-char> ::= \emph{alphabet}

	<meta-char> ::= '?' \alt '*' \alt '+'

	<digit> ::= '0' | '1' | \dots | '9'
\end{grammar}

Следвайки тази граматика за всеки коректно дефиниран регулярен израз извличаме дърво на извод, по което чрез обхождане в дълбочина и строим недетерминиран краен автомат. Представяме автоматите и реализираме операциите по между им (конкатенация, обединение, звезда...) спрямо алгоритъма на Томпсън \cite{Thompson:68}. На Фигура \ref{parsetree} е изобразено дърво на извод на регулярен израз спрямо граматиката.

\begin{figure}
	\Tree[.\emph{expr} 
		[.\emph{term} 
		[.\emph{factor} 
			[.\emph{atom} 
				[( [.\emph{expr} 
					[
						[.\emph{term} [.\emph{factor} [.\emph{atom} [.\emph{char} a ]]]] 
						| 
						[.\emph{expr} [.\emph{term} [.\emph{factor} [.\emph{atom} [.\emph{char} b ]]]]  
					]]] 
				) ]]
			[.* ]]
		[.\emph{term}
			[.\emph{factor}
				[.\emph{atom}
					$[$
					[.\emph{char-class}
						[.\emph{char-class-item} [.\emph{char} 0 ] $-$ [.\emph{char} 9 ] ]]
					$]$ ]]]]]
	\label{parsetree}
	\caption{Дърво на извод за регулярния израз \texttt{(a|b)*[0-9]}, който разпознава думите, започващи с 0 или повече на брой символи 'a' и 'b', които завършват с цифра, на пример \emph{ab3, bbbb4, 9, aa1, baab4} и т.н. }
\end{figure}

Извличането на дърво на извод по зададен регулярен израз реализираме чрез \emph{рекурсивно спускане (recursive descent parser)}. Той спада към класа на типа парсъри, които строят дървото на извод \emph{"от горе надолу" (top-down)}, т.е. от корена към листата, започвайки от аксиомата на граматиката (нашия случай аксиомата е нетерминалът \emph{expr}). Граматически правила се прилагат от ляво на дясно. Регулярен израз е коректно дефиниран, ако по него може да се построи дърво на извод.

Особеност на \emph{top-down} парсърите е, че работят с ограничен клас от безконтекстни граматики. Ако граматиката съдържа \emph{лява рекурсия}, то е възможно процедурата да изпадне в безкраен цикъл поради факта, че правилата се прилагат от ляво на дясно. Нека разгледаме следния пример за директна рекурсия:

\[ A \to A \alpha \mid \beta \]

Символът \(A\) е нетерминал, докато \( \alpha \) и \( \beta \) са думи, съдържащи терминали и нетерминали, които обаче не започват с \(A\). Тъй като прилагаме правилата от ляво на дясно, то \(A\) ще опита първоначално да изведе \(A\) и така ще изпаднем в безкраен цикъл. Решението тук е да преобразуваме правилото до еквивалентната му дясно-рекурсивна форма.

\[ A \to \beta A' \]
\[ A' \to \alpha A' \mid \epsilon \]

Граматиката на регулярен израз не съдържа лява рекурсия, съответно можем по нея да реализираме \emph{recursive descent} парсър. Идеята е следната:

\begin{itemize}
	\item За всеки нетерминал (\emph{expr, term, factor...}) имплементираме отделен метод.
	\item Построяването на дървото започва с извикването на аксиомата на граматиката (\emph{Expr()}).
	\item Използваме методите \emph{Peek()}, за да видим следващия непрочетен символ от входа и \emph{Eat(char ch)}, който сравнява следващия следващия символ с \emph{ch} и преминава с една позиция напред. \emph{Next()} преминава към следващата позиция във входната дума без значение от символа, т.е. \emph{Eat(Peek())}.
\end{itemize}

Нека разгледаме реализацията на правилото за аксиомата на граматиката.

\begin{grammar}
	<expr> ::= <term>
	\alt <term> '|' <expr>
\end{grammar}

Нетерминалът \emph{expr} има два извода, като и двата започват с нетерминала \emph{term}. След като приложим правилото \emph{term}, проверяваме дали не сме стигнали до края на входа и в случай, че следващият символ е операторът за обединението, то местим входната дума с една позиция, прилагаме правилото \emph{expr} и връщаме обединението на резултатите.

\begin{lstlisting}[language=csh]
Fsa Expr() 
{
  var term = Term();
  if (HasMoreChars() && Peek() == '|') {
    Eat('|');
    return term.Union(Expr());
  }
  return term;
}
\end{lstlisting}

Важно е да уточним, че типът \verb/Fsa/ представлява краен автомат т.е. всеки метод, отговарящ на нетерминал в граматиката връща краен автомат. По този начин финалният автомат, съответстващ на регулярния израз се строи директно по време на получаването на дървото на извод. Нека разгледаме метода за нетерминала \emph{char}, който винаги извежда терминален символ, т.е. сме стигнали до листо на дървото.

\begin{lstlisting}[language=csh]
Fsa Char() 
{
  if (Peek() == '\') {
    Eat('\');
    var ch = Next();
    if (!alphabet.Contains(ch))
      throw new Exception($"Invalid char {ch}");
    return FsaBuilder.FromSymbol(ch);
  }	
  var ch = Next();
  if (metaChars.Contains(ch))
    throw new Exception($"Unescaped meta char {ch}");
  return FsaBuilder.FromSymbol(ch);
}
\end{lstlisting}

Ако сме стингали до символа '\textbackslash', последвалият го символ третираме като буква, независимо дали се използва като оператор. Методът връща автомат, който разпознава единствено прочетения символ.

\subsection{Конструкция на преобразувател по стратегията най-ляво-най-дълго срещане}

Дефинираме метода \emph{Fst ToLmlRewriter(Fst t, ISet<char> alphabet)}, който по зададен краен преобразувател \(T\) и входна азбука, строи преобразувател по стратегията най-ляво-най-дълго срещане. Този метод извежда преобразувател, който е еквивалентен на релацията \( R^{LML}(T) \). Алгоритъмът директно следва конструкцията, представена в секция \ref{sec:LexARegRel}. Първоначално имплементираме базовите алгоритми реализиращи операциите над крайни автомати и преобразуватели (конкатенация, идентитет, произведение, композиция и т.н.) представени в \cite{Mihov:2018}. В последствие строим представените оператори над крайни автомати и преобразуватели (\emph{intro, ignore, pIffS ...}) и можем да преминем към реализацията на четирите преобразувателя, съответстващи на \( R^{init}, R^{left}, R^{long}, R^{replace} \). Реализацията на \( R^{init} \) изглежда по следният начин:

\begin{lstlisting}[language=csh,firstnumber=1]
var initialMatch = Intro(allSymbols, new HashSet<char> { cb })
    .Compose(
        LiffR(
            FsaBuilder.FromWord(cb.ToString()),
            XIgnore(fstDomain, allSymbols, new HashSet<char> { cb }))
		.Identity());

var leftToRight = ...
\end{lstlisting}

Цялостната конструкция получаваме като приложим алгоритъма за композиция над тези четири преобразувателя.

\begin{lstlisting}[language=csh,firstnumber=1]
	return initialMatch.Compose(leftToRight, longestMatch, replacement);
\end{lstlisting}

\subsection{От краен преобразувател към бимашина}

Преобразувателят, построен по стратегията най-ляво-най-дълго срещане е функционален, по него можем да построим еквивалентна в бимашина. Ще имплементираме алгоритъма представен в \cite{GerdjikovEtAl:2017}.

Първата стъпка е да детерминираме подлежащия огледален автомат на входния преобразувател. Припомняме, че огледален на даден автомат е такъв, на който сме "обърнали срелките" на преходите.

\begin{lstlisting}[language=csh,firstnumber=1]
Bimachine ToBimachine(this Fst fst, ISet<char> alphabet)
{
    var fstTransGroupedByTarget = fst.Transitions
        .GroupBy(tr => tr.To)
        .ToDictionary(
            g => g.Key, 
            g => g.Select(tr => (In: tr.In, To: tr.From)));

    var rightSStates = new List<ISet<int>> { fst.Final.ToHashSet() };
    var rightTrans = new Dictionary<(int From, char Label), int>();

    for (int n = 0; n < rightSStates.Count; n++) {
        var symbolToSStates = rightSStates[n]
            .Where(st => fstTransGroupedByTarget.ContainsKey(st))
            .SelectMany(st => fstTransGroupedByTarget[st])
            .GroupBy(tr => tr.In, tr => tr.To)
            .ToDictionary(g => g.Key, g => g.ToHashSet());

        foreach (var (symbol, subsetState) in symbolToSStates)
            if (!rightSStates.Any(rs => rs.SetEquals(subsetState)))
                rightSStates.Add(subsetState);
        
        foreach (var (label, targetSState) in symbolToSStates)
            rightTrans.Add(
                (n, label.Single()),
                rightSStates.FindIndex(
                    ss => ss.SetEquals(targetSState)));
	}
\end{lstlisting}

На редове 3-7 групираме преходите на подлежащия автомат по състоянията, \textbf{към които}, има преходи. На пример, ако имаме двата прехода \( \langle p_1, a, c, q \rangle \) и \( \langle p_2, b, d, q \rangle \), то ще получим \( \langle q, \{ \langle a, p_1 \rangle, \langle b, p_2 \rangle \} \rangle \). Използвайки тази структура, строим множествата на състоянията и преходите на детерминирания подлежащ огледален автомат (редове 9-29). Тези множества принадлежат на десния автомат на бимашината.

...

\subsection{Лексически анализ чрез бимашина}

В тази част ще съединим частите на конструкцията от регулярните изрази до построяването на бимашина, както и ще представим алгоритъм за лексически анализ чрез симулация на бимашина. Крайният резултат е програмен интерфейс, който използваме по следния начин:

\begin{lstlisting}[language=csh,firstnumber=1]
var lexer = Lexer.Create(new[] {
    new Rule("[0-9]+\\.?[0-9]*", "NUM"),
    new Rule("[+*/-]", "OP"),
    new Rule("=", "EQ"),
});
lexer.Input = new InputStream("3.14+1.86=5");

foreach (Token token in lexer.GetNextToken())
    Console.WriteLine(token);
\end{lstlisting}

Тази програма ще генерира лексически анализатор, извърши токенизацията на аритметичен израз и изведе следният резултат

\begin{lstlisting}[language=bash]
[@0,0:3='3.14',<NUM>]
[@1,4:4='+',<OP>]
[@2,5:8='1.86',<NUM>]
[@3,9:9='=',<EQ>]
[@4,10:10='5',<NUM>]
\end{lstlisting}

Разглеждаме процедурата по създаване на лексическия анализатор.

\begin{lstlisting}[language=csh]
const char SoT = '\u0002';
const char EoT = '\u0003';

static Lexer Create(IList<Rule> grammar)
{
    var tokenFsts = new List<Fst>();

    for (int i = 0; i < grammar.Count; i++) {
        var ruleFsa = new RegExp(grammar[i].Pattern).Automaton;
        var ruleFst = FstBuilder.FromWordPair("", $"{i}{SoT}")
            .Concat(ruleFsa.Identity())
            .Concat(FstBuilder.FromWordPair("", $"{EoT}"));
        tokenFsts.Add(ruleFst);
    }

    var unionFst = tokenFsts.Aggregate((u, f) => u.Union(f));
    var alphabet = unionFst.InputAlphabet
	    .Where(s => !string.IsNullOrEmpty(s))
	    .Select(s => s.Single())
	    .ToHashSet();

    var lmlFst = unionFst.ToLmlRewriter(alphabet);
    var bm = lmlFst.ToBimachine(alphabet);

    return new Lexer(bm, grammar);
}
\end{lstlisting}

На редове 1-2 декларираме символите, с които ще означаваме началото и края на лексемите. На 6-14 обхождаме правилата в граматиката и по регулярния израз на всяко строим краен автомат. В последствие по този автомат получаваме преобразувател, който за всяка дума в езика му ще изведе думата с прикрепяйки индекса на правилото и маркерите за начало и край. На 16-20 обединяваме тези преобразуватели и определяме азбуката като вземем уникалните символи по горната лента на получения преобразувател. От него на ред 22 строим такъв под стратегията "най-ляво-най-дълго" срещане, който превръщаме в еквивалентна бимашина (ред 23). 

\begin{lstlisting}[language=csh]
class Dfsa
{
    public IList<int> States { get; set; }
    public int Initial { get; set; }
    public IList<int> Final { get; set; }
    public IDictionary<(int From, char Label), int> 
        Transitions { get; set; }
}
\end{lstlisting}

Така представяме детерминиран краен автомат, като функциата на прехода реализираме като двойки ключ-стойност, където ключът е двойка от състояние и символ, а стойността е състоянието, в което попадаме след този преход.

\begin{lstlisting}[language=csh]
class Bimachine
{
    public Dfsa Left { get; set; }
    public Dfsa Right { get; set; }
    public IDictionary<(int Lstate, char Symbol, int Rstate), string> 
        Output { get; private set; }
}
\end{lstlisting}

Аналогично за бимашината имаме два автомата. "Left" отговаря на левия автомат, който сканира текста от ляво на дясно и "Right", който сканира текста от дясно на ляво. Функцията на изхода са двойки ключ-стойност, където ключът е тройка, състояща се от състояние на левия автомат, входен символ и състояние на десния автомат, стойността е изведената дума. Вече сме готови да представим метода за токенизация.

\begin{lstlisting}[language=csh]
class Lexer
{
    char SoT = '\u0002';
    char EoT = '\u0003';
    IList<Rule> grammar;

    Lexer(Bimachine bm, IList<Rule> grammar)
    {
        this.Bm = bm;
        this.grammar = grammar;
    }

    public Bimachine Bm { get; set; }
    public InputStream Input { get; set; }
\end{lstlisting}

Лексическият анализатор пази референции към граматиката и съответстващата ѝ бимашина. Типът \emph{InputStream} е абстракция на входния текст, който може да се подаде като низ от символи в паметта или зареди от текстов файл.

\begin{lstlisting}[language=csh,firstnumber=15]
    public IEnumerable<Token> GetNextToken()
    {
        var rPath = Bm.Right.ReverseRecognitionPath(Input);

        if (rPath.Count != Input.Size + 1)
            throw new ArgumentException(
                $"Invalid input symbol. {Input.CharAt(Input.Size - rPath.Count)}");

        var leftState = Bm.Left.Initial;
        var token = new StringBuilder();
        var typeIndex = new StringBuilder();
        var tokenIndex = 0;
        var tokenStartPos = 0;

        for (Input.SetToStart(); !Input.IsExhausted; Input.MoveForward())
        {
            var ch = Input.Peek();
            var rightIndex = rPath.Count - 2 - Input.Pos;
            var triple = (leftState, ch, rPath[rightIndex]);

            if (!Bm.Output.ContainsKey(triple))
                throw new ArgumentException($"Invalid token '{token.ToString() + ch}'");

            token.Append(Bm.Output[triple]);

            if (token[token.Length - 1] == EoT)
            {
                token.Remove(token.Length - 1, 1);
                for (var i = 0; token[i] != SoT; i++)
                    typeIndex.Append(token[i]);
                token.Remove(0, typeIndex.Length + 1);

                yield return new Token
                {
                    Index = tokenIndex,
                    Position = (tokenStartPos, Input.Pos),
                    Text = token.ToString(),
                    Type = grammar[int.Parse(typeIndex.ToString())].Name
                };

                token.Clear();
                typeIndex.Clear();
                tokenIndex++;
                tokenStartPos = Input.Pos + 1;
            }

            if (!Bm.Left.Transitions.ContainsKey((leftState, ch)))
                throw new ArgumentException($"Invalid input. {ch}");

            leftState = Bm.Left.Transitions[(leftState, ch)];
        }
    }
}
\end{lstlisting}

На ред 17 извличаме редицата от състояния получена от симулацията на десния авомат, прочитайки входния текст от дясно на ляво. Ако автоматът не е автоматът не е прочел целия текст, то входът е невалиден връщаме грешка (19-21). Започваме симулацията на левия автомат, заедно с извеждането на лексемите. Намираме се в началното му състояние (23), променливата \emph{token} (24) изпозваме, за да съхраняваме текста на прочетената лексема, \emph{typeIndex} (25) съдържа индекса на правилото в граматиката, чрез който определяме какъв тип е изведената лексема, \emph{tokenIndex} (26) определя коя по ред лексема сме извели, а \emph{tokenStartPos} (27) показва на коя позиция в текста започва лексемата. Четем входа от лявно на дясно и на всеки прочетен символ формираме тройката от ляво, дясно състояние и входен символ (29-33). Ако фукнцията на изхода не е дефинирана за тази тройка, връщаме грешка, в противен случай конкатенираме изходната дума към текста, който сме извели до момента (35-38). Ако последният символ на изведената дума е маркер за край на лемсема (end of token) (40), то сме разпознали лексема и преминаваме към извеждането ѝ. В този момент \emph{token} е низ, който съдържа едновременно идекса на лексемата и нейната стойност (\verb/<index> SoT <text> EoT/). Елиминираме маркера за край, прочитаме символите от началото докато стигнем до \verb/SoT/, което представлява индекса на правилото, съхраняваме ги в \emph{tokenIndex} и елиминираме сегмента, така че в \emph{token} да остане само текста на лексемата (42-45), докато \emph{tokenIndex} съдържа идекса на правилото в граматиката.  На редове 47-53 извеждаме обект, който съдържа данните на разпознатата лексема - нейният индекс, позиция, текст и тип. Чрез ключовата дума \verb/yield/ указваме, че при следващото извикване на \emph{GetNextToken()}, методът ще продължи изпълнението си, от където е приключил. Подготвяме променливите за разпознаването на следващата лексема (55-58) и продължаваме с итерацията над входния текст, докато не стигнем неговия край, или пък докато левия автомат не може да продължи (61-64).

\pagebreak
\begin{thebibliography}{9}
	\bibitem{Kaplan&Kay:94} 
	Kaplan, Ronald and Kay, Martin. (1994)
	\textit{Regular models of phonological rule systems.}
	Computational Linguistics 20(3):331-378

	\bibitem{Thompson:68} 
	Thompson, Ken (1968) 
	\textit{Regular Expression Search Algorithm.} 
	Association for Computing Machinery

	\bibitem{Mihov:2018}
	S., Mihov, S., and Schulz, K. U. (2018)
	\textit{Finite-State Techniques Automata, Transducers and Bimachines}
	Chapter 11 "Constructing finite-state devices for text rewriting"

	\bibitem{Karttunen:96}
	Karttunen, Lauri. (1996)
	\textit{Directed Replacement.}
	In Joshi, A. and Palmer, M., editors, Proceedings of the 34th Annual Meeting of the As- sociation for Computational Linguistics, pages 108–115, Santa Cruz.

	\bibitem{GerdjikovEtAl:2017}
	Gerdjikov, S., Mihov, S., and Schulz, K. U. (2017)
	\textit{A simple method for building bimachines from functional finite-state transducers.} 
	Carayol, A. and Nicaud, C., editors, Implementation and Application of Automata, pages 113–125. Springer International Publishing.

	\bibitem{Schutzenberger:61} 
	Schützenberger, M.-P. (1961)
	\textit{A remark on finite transducers.} 
	Information and Control, 4:185–196.

\end{thebibliography}	

\end{document}
